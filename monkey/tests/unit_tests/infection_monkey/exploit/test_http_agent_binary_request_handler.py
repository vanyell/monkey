import threading
from http import HTTPStatus
from http.server import HTTPServer
from io import BytesIO
from typing import Final, Type
from unittest.mock import MagicMock

import pytest
import requests
from agentpluginapi import (
    AgentBinaryDownloadReservation,
    IAgentBinaryRepository,
    ReservationID,
    RetrievalError,
)
from monkeytypes import OperatingSystem

from infection_monkey.exploit.http_agent_binary_request_handler import (
    AgentBinaryHTTPRequestHandler,
    get_http_handler,
)

AGENT_BINARY: Final = b"agent_binary"
DROPPER_BINARY: Final = b"dropper_agent_binary"
IP: Final = "127.0.0.1"
RESERVATION_ID_1: Final = ReservationID("abcABC1")
RESERVATION_ID_2: Final = ReservationID("abcABC2")
RESERVATION_ID_3: Final = ReservationID("abcABC2")

DEFAULT_AGENT_TEMPLATE: Final = b"%(agent_binary)s"
DROPPER_AGENT_TEMPLATE: Final = b"dropper_%(agent_binary)s"


@pytest.fixture
def port(tcp_port_selector) -> int:
    return int(tcp_port_selector.get_free_tcp_port())


@pytest.fixture
def binary_request_1(port) -> AgentBinaryDownloadReservation:
    return AgentBinaryDownloadReservation(
        RESERVATION_ID_1,
        OperatingSystem.LINUX,
        DEFAULT_AGENT_TEMPLATE,
        f"http://{IP}:{port}/{RESERVATION_ID_1}",
        threading.Event(),
    )


@pytest.fixture
def binary_request_2(port) -> AgentBinaryDownloadReservation:
    return AgentBinaryDownloadReservation(
        RESERVATION_ID_2,
        OperatingSystem.WINDOWS,
        DEFAULT_AGENT_TEMPLATE,
        f"http://{IP}:{port}/{RESERVATION_ID_2}",
        threading.Event(),
    )


@pytest.fixture
def binary_request_3(port) -> AgentBinaryDownloadReservation:
    return AgentBinaryDownloadReservation(
        RESERVATION_ID_2,
        OperatingSystem.WINDOWS,
        None,
        f"http://{IP}:{port}/{RESERVATION_ID_2}",
        threading.Event(),
    )


@pytest.fixture
def dropper_request_1(port) -> AgentBinaryDownloadReservation:
    return AgentBinaryDownloadReservation(
        RESERVATION_ID_1,
        OperatingSystem.LINUX,
        DROPPER_AGENT_TEMPLATE,
        f"http://{IP}:{port}/{RESERVATION_ID_1}",
        threading.Event(),
    )


@pytest.fixture
def dropper_request_2(port) -> AgentBinaryDownloadReservation:
    return AgentBinaryDownloadReservation(
        RESERVATION_ID_2,
        OperatingSystem.WINDOWS,
        DROPPER_AGENT_TEMPLATE,
        f"http://{IP}:{port}/{RESERVATION_ID_2}",
        threading.Event(),
    )


@pytest.fixture
def agent_binary_repository() -> IAgentBinaryRepository:
    return MagicMock(spec=IAgentBinaryRepository)


@pytest.fixture
def agent_binary_http_handler(
    agent_binary_repository: IAgentBinaryRepository,
) -> Type[AgentBinaryHTTPRequestHandler]:
    return get_http_handler(agent_binary_repository, {}, {}, lambda: threading.Lock())


@pytest.fixture
def http_server(port, agent_binary_http_handler: Type[AgentBinaryHTTPRequestHandler]):
    server = HTTPServer(("127.0.0.1", port), agent_binary_http_handler)
    server_thread = threading.Thread(target=server.serve_forever)
    server_thread.start()

    yield server

    server.shutdown()
    server_thread.join()


def test_get_http_handler__provides_unique_types(agent_binary_repository: IAgentBinaryRepository):
    handler1 = get_http_handler(agent_binary_repository, {}, {}, lambda: threading.Lock())
    handler2 = get_http_handler(agent_binary_repository, {}, {}, lambda: threading.Lock())

    assert handler1 is not handler2
    assert handler1.locks is not handler2.locks
    assert handler1.reservations is not handler2.reservations


@pytest.mark.parametrize(
    "agent_binary_request_fixture",
    [
        "binary_request_1",
        "binary_request_2",
        "binary_request_3",
        "dropper_request_1",
        "dropper_request_2",
    ],
)
def test_reserve_download__succeeds(
    agent_binary_http_handler: AgentBinaryHTTPRequestHandler,
    agent_binary_request_fixture: AgentBinaryDownloadReservation,
    request,
):
    agent_binary_request = request.getfixturevalue(agent_binary_request_fixture)
    agent_binary_http_handler.reserve_download(agent_binary_request)


@pytest.mark.parametrize("first_request_fixture", ["binary_request_1", "dropper_request_1"])
@pytest.mark.parametrize("second_request_fixture", ["binary_request_2", "dropper_request_2"])
def test_reserve_download__allows_multiple_reservations(
    agent_binary_http_handler: AgentBinaryHTTPRequestHandler,
    first_request_fixture: AgentBinaryDownloadReservation,
    second_request_fixture: AgentBinaryDownloadReservation,
    request,
):
    first_request = request.getfixturevalue(first_request_fixture)
    second_request = request.getfixturevalue(second_request_fixture)
    agent_binary_http_handler.reserve_download(first_request)
    agent_binary_http_handler.reserve_download(second_request)


def test_reserve_download__fails_if_request_exists(
    agent_binary_http_handler: AgentBinaryHTTPRequestHandler,
    binary_request_1: AgentBinaryDownloadReservation,
):
    agent_binary_http_handler.reserve_download(binary_request_1)
    with pytest.raises(KeyError):
        agent_binary_http_handler.reserve_download(binary_request_1)


@pytest.mark.parametrize(
    "agent_binary_request_fixture",
    ["binary_request_1", "binary_request_2", "binary_request_3"],
)
def test_clear_reservation__succeeds(
    agent_binary_http_handler: AgentBinaryHTTPRequestHandler,
    agent_binary_request_fixture: AgentBinaryDownloadReservation,
    request,
):
    agent_binary_request = request.getfixturevalue(agent_binary_request_fixture)
    agent_binary_http_handler.reserve_download(agent_binary_request)
    agent_binary_http_handler.clear_reservation(agent_binary_request.id)


def test_clear_reservation__fails_if_request_does_not_exist(
    agent_binary_http_handler: AgentBinaryHTTPRequestHandler,
    binary_request_1: AgentBinaryDownloadReservation,
):
    with pytest.raises(KeyError):
        agent_binary_http_handler.clear_reservation(binary_request_1.id)


@pytest.mark.xdist_group(name="tcp_port_selector")
@pytest.mark.usefixtures("http_server")
def test_agent_binary_request__succeeds(
    agent_binary_http_handler: Type[AgentBinaryHTTPRequestHandler],
    agent_binary_repository: IAgentBinaryRepository,
    binary_request_1: AgentBinaryDownloadReservation,
):
    request = binary_request_1
    agent_binary_repository.get_agent_binary.return_value = BytesIO(  # type: ignore[attr-defined]
        AGENT_BINARY
    )

    agent_binary_http_handler.reserve_download(request)
    response = requests.get(request.download_url)

    assert response.status_code == HTTPStatus.OK
    assert response.content == AGENT_BINARY


@pytest.mark.xdist_group(name="tcp_port_selector")
@pytest.mark.usefixtures("http_server")
def test_agent_binary_request__fails_if_no_binary_available(
    agent_binary_http_handler: Type[AgentBinaryHTTPRequestHandler],
    agent_binary_repository: IAgentBinaryRepository,
    binary_request_1: AgentBinaryDownloadReservation,
):
    request = binary_request_1
    agent_binary_repository.get_agent_binary.side_effect = (  # type: ignore[attr-defined]
        RetrievalError
    )

    agent_binary_http_handler.reserve_download(request)
    response = requests.get(request.download_url)

    assert response.status_code == HTTPStatus.INTERNAL_SERVER_ERROR


@pytest.mark.xdist_group(name="tcp_port_selector")
@pytest.mark.usefixtures("http_server")
def test_agent_binary_request__fails_if_unregistered(
    binary_request_1: AgentBinaryDownloadReservation,
    agent_binary_repository: IAgentBinaryRepository,
):
    request = binary_request_1
    agent_binary_repository.get_agent_binary.return_value = BytesIO(  # type: ignore[attr-defined]
        AGENT_BINARY
    )

    # We haven't registered the request
    response = requests.get(request.download_url)

    assert response.status_code == HTTPStatus.NOT_FOUND
    assert response.content != AGENT_BINARY


@pytest.mark.xdist_group(name="tcp_port_selector")
@pytest.mark.usefixtures("http_server")
def test_agent_binary_request__fails_if_already_downloaded(
    agent_binary_http_handler: Type[AgentBinaryHTTPRequestHandler],
    agent_binary_repository: IAgentBinaryRepository,
    binary_request_1: AgentBinaryDownloadReservation,
):
    request = binary_request_1
    agent_binary_repository.get_agent_binary.return_value = BytesIO(  # type: ignore[attr-defined]
        AGENT_BINARY
    )

    agent_binary_http_handler.reserve_download(request)
    first_response = requests.get(request.download_url)
    second_response = requests.get(request.download_url)

    assert first_response.status_code == HTTPStatus.OK
    assert first_response.content == AGENT_BINARY
    assert second_response.status_code == HTTPStatus.TOO_MANY_REQUESTS
    assert second_response.content != AGENT_BINARY


@pytest.mark.xdist_group(name="tcp_port_selector")
@pytest.mark.usefixtures("http_server")
def test_agent_binary_request__is_transformed_if_none(
    agent_binary_http_handler: Type[AgentBinaryHTTPRequestHandler],
    agent_binary_repository: IAgentBinaryRepository,
    binary_request_3: AgentBinaryDownloadReservation,
):
    request = binary_request_3
    agent_binary_repository.get_agent_binary.return_value = BytesIO(  # type: ignore[attr-defined]
        AGENT_BINARY
    )

    agent_binary_http_handler.reserve_download(request)
    response = requests.get(request.download_url)

    assert response.status_code == HTTPStatus.OK
    assert response.content == AGENT_BINARY


@pytest.mark.xdist_group(name="tcp_port_selector")
@pytest.mark.usefixtures("http_server")
def test_agent_binary_request__is_transformed(
    agent_binary_http_handler: Type[AgentBinaryHTTPRequestHandler],
    agent_binary_repository: IAgentBinaryRepository,
    dropper_request_1: AgentBinaryDownloadReservation,
):
    request = dropper_request_1
    agent_binary_repository.get_agent_binary.return_value = BytesIO(  # type: ignore[attr-defined]
        AGENT_BINARY
    )

    agent_binary_http_handler.reserve_download(request)
    response = requests.get(request.download_url)

    assert response.status_code == HTTPStatus.OK
    assert response.content == DROPPER_BINARY
    assert response.content == DROPPER_BINARY
